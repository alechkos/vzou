import { PseudoItem } from "./pc-helpers";

export type HashTableAlgNames = keyof typeof HashTablePseudoCode;

export const HashTablePseudoCode = {
  ChainingSearch1: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑪𝒉𝒂𝒊𝒏𝒊𝒏𝒈𝑺𝒆𝒂𝒓𝒄𝒉(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝘪𝘯𝘥𝘦𝘹 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬)", tabAmount: 1 },
    { text: "𝘹 ← 𝘛[𝘪𝘯𝘥𝘦𝘹];", tabAmount: 1 },
    { text: "𝑤ℎ𝑖𝑙𝑒 (𝑥 ≠ 𝑁𝑢𝑙𝑙 𝑎𝑛𝑑 𝑥.𝑘𝑒𝑦 ≠ 𝑘):", tabAmount: 1 },
    { text: "𝑥 ← 𝑥.𝑛𝑒𝑥𝑡", tabAmount: 2 },
    { text: "𝑟𝑒𝑡𝑢𝑟𝑛 𝑥", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬):", tabAmount: 1 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝘬 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
  ] as PseudoItem[],
  ChainingSearch2: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑪𝒉𝒂𝒊𝒏𝒊𝒏𝒈𝑺𝒆𝒂𝒓𝒄𝒉(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝘪𝘯𝘥𝘦𝘹 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬)", tabAmount: 1 },
    { text: "𝘹 ← 𝘛[𝘪𝘯𝘥𝘦𝘹];", tabAmount: 1 },
    { text: "𝑤ℎ𝑖𝑙𝑒 (𝑥 ≠ 𝑁𝑢𝑙𝑙 𝑎𝑛𝑑 𝑥.𝑘𝑒𝑦 ≠ 𝑘):", tabAmount: 1 },
    { text: "𝑥 ← 𝑥.𝑛𝑒𝑥𝑡", tabAmount: 2 },
    { text: "𝑟𝑒𝑡𝑢𝑟𝑛 𝑥", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬):", tabAmount: 1 },
    { text: "0 < 𝘈 < 1", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 ⌊𝒎 * (𝒌𝑨 𝒎𝒐𝒅 𝟏)⌋", tabAmount: 2 },
  ] as PseudoItem[],
  ChainingInsert1: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑪𝒉𝒂𝒊𝒏𝒊𝒏𝒈𝑰𝒏𝒔𝒆𝒓𝒕(𝑻, 𝒌):", tabAmount: 0 },
    { text: "𝘪𝘯𝘥𝘦𝘹 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬)", tabAmount: 1 },
    { text: "𝘛[𝘪𝘯𝘥𝘦𝘹].𝘶𝘯𝘴𝘩𝘪𝘧𝘵(𝘬)", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬):", tabAmount: 1 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝘬 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
  ] as PseudoItem[],
  ChainingInsert2: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑪𝒉𝒂𝒊𝒏𝒊𝒏𝒈𝑰𝒏𝒔𝒆𝒓𝒕(𝑻, 𝒌):", tabAmount: 0 },
    { text: "𝘪𝘯𝘥𝘦𝘹 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬)", tabAmount: 1 },
    { text: "𝘛[𝘪𝘯𝘥𝘦𝘹].𝘶𝘯𝘴𝘩𝘪𝘧𝘵(𝘬)", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬):", tabAmount: 1 },
    { text: "0 < 𝘈 < 1", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 ⌊𝒎 * (𝒌𝑨 𝒎𝒐𝒅 𝟏)⌋", tabAmount: 2 },
  ] as PseudoItem[],
  ChainingDelete1: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑪𝒉𝒂𝒊𝒏𝒊𝒏𝒈𝑫𝒆𝒍𝒆𝒕𝒆(𝑻, 𝒌):", tabAmount: 0 },
    { text: "𝘪𝘯𝘥𝘦𝘹 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬)", tabAmount: 1 },
    { text: "𝘹 ← 𝘛[𝘪𝘯𝘥𝘦𝘹];", tabAmount: 1 },
    { text: "𝑤ℎ𝑖𝑙𝑒 (𝑥 ≠ 𝑁𝑢𝑙𝑙 𝑎𝑛𝑑 𝑥.𝑘𝑒𝑦 ≠ 𝑘)", tabAmount: 1 },
    { text: "𝑥 ← 𝑥.𝑛𝑒𝑥𝑡", tabAmount: 2 },
    { text: "𝘪𝘧(𝘹 ≠ 𝘕𝘶𝘭𝘭):", tabAmount: 1 },
    { text: "𝘪𝘧(𝘹.𝘯𝘦𝘹𝘵 ≠ 𝘕𝘶𝘭𝘭):", tabAmount: 2 },
    { text: "𝘹.𝘯𝘦𝘹𝘵 = (𝘹.𝘯𝘦𝘹𝘵).𝘯𝘦𝘹𝘵", tabAmount: 3 },
    { text: "𝘦𝘭𝘴𝘦 𝘹 = 𝘕𝘶𝘭𝘭", tabAmount: 2 },
    { text: "𝘦𝘭𝘴𝘦 𝘦𝘳𝘳𝘰𝘳: '𝘷𝘢𝘭𝘶𝘦 𝘯𝘰𝘵 𝘧𝘰𝘶𝘯𝘥'", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬):", tabAmount: 1 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝘬 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
  ] as PseudoItem[],
  ChainingDelete2: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑪𝒉𝒂𝒊𝒏𝒊𝒏𝒈𝑫𝒆𝒍𝒆𝒕𝒆(𝑻, 𝒌):", tabAmount: 0 },
    { text: "𝘪𝘯𝘥𝘦𝘹 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬)", tabAmount: 1 },
    { text: "𝘹 ← 𝘛[𝘪𝘯𝘥𝘦𝘹];", tabAmount: 1 },
    { text: "𝑤ℎ𝑖𝑙𝑒 (𝑥 ≠ 𝑁𝑢𝑙𝑙 𝑎𝑛𝑑 𝑥.𝑘𝑒𝑦 ≠ 𝑘)", tabAmount: 1 },
    { text: "𝑥 ← 𝑥.𝑛𝑒𝑥𝑡", tabAmount: 2 },
    { text: "𝘪𝘧(𝘹 ≠ 𝘕𝘶𝘭𝘭):", tabAmount: 1 },
    { text: "𝘪𝘧(𝘹.𝘯𝘦𝘹𝘵 ≠ 𝘕𝘶𝘭𝘭):", tabAmount: 2 },
    { text: "𝘹.𝘯𝘦𝘹𝘵 = (𝘹.𝘯𝘦𝘹𝘵).𝘯𝘦𝘹𝘵", tabAmount: 3 },
    { text: "𝘦𝘭𝘴𝘦 𝘹 = 𝘕𝘶𝘭𝘭", tabAmount: 2 },
    { text: "𝘦𝘭𝘴𝘦 𝘦𝘳𝘳𝘰𝘳: '𝘷𝘢𝘭𝘶𝘦 𝘯𝘰𝘵 𝘧𝘰𝘶𝘯𝘥'", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝘛.𝘭𝘦𝘯𝘨𝘵𝘩, 𝘬):", tabAmount: 1 },
    { text: "0 < 𝘈 < 1", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 ⌊𝒎 * (𝒌𝑨 𝒎𝒐𝒅 𝟏)⌋", tabAmount: 2 },
  ] as PseudoItem[],
  Search1: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑨𝒅𝒅𝒓𝒆𝒔𝒔𝒊𝒏𝒈𝑺𝒆𝒂𝒓𝒄𝒉(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝑖 ← 0", tabAmount: 1 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 1 },
    { text: "𝘸𝘩𝘪𝘭𝘦 𝑖 < 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩 𝐀𝐍𝐃 𝑇[𝑗] ≠ 𝑁𝑈𝐿𝐿:", tabAmount: 1 },
    { text: "𝘪𝘧 𝑇[𝑗].𝑘𝑒𝑦 = 𝑘:", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝑇[𝑗]", tabAmount: 3 },
    { text: "𝑖 ← 𝑖 + 1", tabAmount: 2 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 2 },
    { text: "𝑟𝑒𝑡𝑢𝑟𝑛 𝑁𝑢𝑙𝑙", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬):", tabAmount: 1 },
    { text: "𝘩'(𝘬) = 𝘬𝘦𝘺 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 (𝘩'(𝘬) + 𝘪)𝘮𝘰𝘥 𝘮", tabAmount: 2 },
  ] as PseudoItem[],
  Search2: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑨𝒅𝒅𝒓𝒆𝒔𝒔𝒊𝒏𝒈𝑺𝒆𝒂𝒓𝒄𝒉(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝑖 ← 0", tabAmount: 1 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 1 },
    { text: "𝘸𝘩𝘪𝘭𝘦 𝑖 < 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩 𝐀𝐍𝐃 𝑇[𝑗] ≠ 𝑁𝑈𝐿𝐿:", tabAmount: 1 },
    { text: "𝘪𝘧 𝑇[𝑗].𝑘𝑒𝑦 = 𝑘:", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝑇[𝑗]", tabAmount: 3 },
    { text: "𝑖 ← 𝑖 + 1", tabAmount: 2 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 2 },
    { text: "𝑟𝑒𝑡𝑢𝑟𝑛 𝑁𝑢𝑙𝑙", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬):", tabAmount: 1 },
    { text: "𝘩1(𝘬) = 𝘬𝘦𝘺 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
    { text: "𝘩2(𝘬) = 1 + (𝘬𝘦𝘺 𝘮𝘰𝘥 (𝘛.𝘭𝘦𝘯𝘨𝘵𝘩- 2))", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝘩1(𝘬) + 𝘪𝘩2(𝘬) 𝘮𝘰𝘥 𝘮", tabAmount: 2 },
  ] as PseudoItem[],
  Insert1: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑨𝒅𝒅𝒓𝒆𝒔𝒔𝒊𝒏𝒈𝑰𝒏𝒔𝒆𝒓𝒕(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝑖 ← 0", tabAmount: 1 },
    { text: "𝘸𝘩𝘪𝘭𝘦 𝑖 < 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩:", tabAmount: 1 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 2 },
    { text: "𝘪𝘧 𝑇[𝑗] = 𝑁𝑢𝑙𝑙:", tabAmount: 2 },
    { text: "𝑇[𝑗] = 𝑘:", tabAmount: 3 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝑗", tabAmount: 3 },
    { text: "𝘦𝘭𝘴𝘦 𝑖 ← 𝑖 + 1", tabAmount: 2 },
    { text: "𝘦𝘳𝘳𝘰𝘳 '𝘩𝘢𝘴𝘩 𝘵𝘢𝘣𝘭𝘦 𝘰𝘷𝘦𝘳𝘧𝘭𝘰𝘸'", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬):", tabAmount: 1 },
    { text: "𝘩'(𝘬) = 𝘬𝘦𝘺 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 (𝘩'(𝘬) + 𝘪)𝘮𝘰𝘥 𝘮", tabAmount: 2 },
  ] as PseudoItem[],
  Insert2: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑨𝒅𝒅𝒓𝒆𝒔𝒔𝒊𝒏𝒈𝑰𝒏𝒔𝒆𝒓𝒕(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝑖 ← 0", tabAmount: 1 },
    { text: "𝘸𝘩𝘪𝘭𝘦 𝑖 < 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩:", tabAmount: 1 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 2 },
    { text: "𝘪𝘧 𝑇[𝑗] = 𝑁𝑢𝑙𝑙:", tabAmount: 2 },
    { text: "𝑇[𝑗] = 𝑘:", tabAmount: 3 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝑗", tabAmount: 3 },
    { text: "𝘦𝘭𝘴𝘦 𝑖 ← 𝑖 + 1", tabAmount: 2 },
    { text: "𝘦𝘳𝘳𝘰𝘳 '𝘩𝘢𝘴𝘩 𝘵𝘢𝘣𝘭𝘦 𝘰𝘷𝘦𝘳𝘧𝘭𝘰𝘸'", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬):", tabAmount: 1 },
    { text: "𝘩1(𝘬) = 𝘬𝘦𝘺 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
    { text: "𝘩2(𝘬) = 1 + (𝘬𝘦𝘺 𝘮𝘰𝘥 (𝘛.𝘭𝘦𝘯𝘨𝘵𝘩- 2))", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝘩1(𝘬) + 𝘪𝘩2(𝘬) 𝘮𝘰𝘥 𝘮", tabAmount: 2 },
  ] as PseudoItem[],
  Delete1: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑨𝒅𝒅𝒓𝒆𝒔𝒔𝒊𝒏𝒈𝑫𝒆𝒍𝒆𝒕𝒆(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝑖 ← 0", tabAmount: 1 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 1 },
    { text: "𝘸𝘩𝘪𝘭𝘦 𝑖 < 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩 𝐀𝐍𝐃 𝑇[𝑗] ≠ 𝑁𝑈𝐿𝐿:", tabAmount: 1 },
    { text: "𝘪𝘧 𝑇[𝑗].𝑘𝑒𝑦 = 𝑘:", tabAmount: 2 },
    { text: "𝑇[𝑗] = 'Deleted'", tabAmount: 3 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝑇", tabAmount: 3 },
    { text: "𝑖 ← 𝑖 + 1", tabAmount: 2 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 2 },
    { text: "𝘦𝘳𝘳𝘰𝘳: '𝘷𝘢𝘭𝘶𝘦 𝘯𝘰𝘵 𝘧𝘰𝘶𝘯𝘥'", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬):", tabAmount: 1 },
    { text: "𝘩'(𝘬) = 𝘬𝘦𝘺 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 (𝘩'(𝘬) + 𝘪)𝘮𝘰𝘥 𝘮", tabAmount: 2 },
  ] as PseudoItem[],
  Delete2: [
    { text: "𝑯𝒂𝒔𝒉𝑻𝒂𝒃𝒍𝒆 - 𝑨𝒅𝒅𝒓𝒆𝒔𝒔𝒊𝒏𝒈𝑫𝒆𝒍𝒆𝒕𝒆(𝑻, 𝒌, 𝒉𝒂𝒔𝒉𝑭𝒖𝒏𝒄):", tabAmount: 0 },
    { text: "𝑖 ← 0", tabAmount: 1 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 1 },
    { text: "𝘸𝘩𝘪𝘭𝘦 𝑖 < 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩 𝐀𝐍𝐃 𝑇[𝑗] ≠ 𝑁𝑈𝐿𝐿:", tabAmount: 1 },
    { text: "𝘪𝘧 𝑇[𝑗].𝑘𝑒𝑦 = 𝑘:", tabAmount: 2 },
    { text: "𝑇[𝑗] = 'Deleted'", tabAmount: 3 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝑇", tabAmount: 3 },
    { text: "𝑖 ← 𝑖 + 1", tabAmount: 2 },
    { text: "𝑗 ← 𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬)", tabAmount: 2 },
    { text: "𝘦𝘳𝘳𝘰𝘳: '𝘷𝘢𝘭𝘶𝘦 𝘯𝘰𝘵 𝘧𝘰𝘶𝘯𝘥'", tabAmount: 1 },
    { text: "", tabAmount: 1 },
    { text: "𝘩𝘢𝘴𝘩𝘍𝘶𝘯𝘤(𝑖, 𝘬):", tabAmount: 1 },
    { text: "𝘩1(𝘬) = 𝘬𝘦𝘺 𝘮𝘰𝘥 𝘛.𝘭𝘦𝘯𝘨𝘵𝘩", tabAmount: 2 },
    { text: "𝘩2(𝘬) = 1 + (𝘬𝘦𝘺 𝘮𝘰𝘥 (𝘛.𝘭𝘦𝘯𝘨𝘵𝘩- 2))", tabAmount: 2 },
    { text: "𝘳𝘦𝘵𝘶𝘳𝘯 𝘩1(𝘬) + 𝘪𝘩2(𝘬) 𝘮𝘰𝘥 𝘮", tabAmount: 2 },
  ] as PseudoItem[],
};

export const HashTablePseudoCodeList = {
  ChainingSearch1: ["ChainingSearch1"] as HashTableAlgNames[],
  ChainingInsert1: ["ChainingInsert1"] as HashTableAlgNames[],
  ChainingDelete1: ["ChainingDelete1"] as HashTableAlgNames[],
  ChainingSearch2: ["ChainingSearch2"] as HashTableAlgNames[],
  ChainingInsert2: ["ChainingInsert2"] as HashTableAlgNames[],
  ChainingDelete2: ["ChainingDelete2"] as HashTableAlgNames[],
  Search1: ["Search1"] as HashTableAlgNames[],
  Insert1: ["Insert1"] as HashTableAlgNames[],
  Delete1: ["Delete1"] as HashTableAlgNames[],
  Search2: ["Search2"] as HashTableAlgNames[],
  Insert2: ["Insert2"] as HashTableAlgNames[],
  Delete2: ["Delete2"] as HashTableAlgNames[],
};

export type HashTablePseudoCodeKeys = keyof typeof HashTablePseudoCodeList;
